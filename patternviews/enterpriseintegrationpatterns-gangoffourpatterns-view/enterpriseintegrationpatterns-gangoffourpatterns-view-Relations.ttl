# Definition of prefixes
@prefix : <https://purl.org/patternpedia/patternviews/https://purl.org/patternpedia/patternviews/enterpriseintegrationpatterns-gangoffourpatterns-view#> .
@prefix pp: <https://purl.org/patternpedia#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix eip: <https://purl.org/patternpedia/patternlanguages/enterpriseintegrationpatterns#> .
@prefix gof: <https://purl.org/patternpedia/patternlanguages/gangoffourpatterns#> .


:Key-ValueStorage-to-DomainModel
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:Key-ValueStorage ;
    pp:hasTarget eaa:DomainModel ;
    pp:hasDescription "The domain model, consisting of data and the functionality to access it, decides whether key-value storage is the right choice. Patterns for domain models can be found in the Patterns of Enterprise Application Architecture by Fowler et al., which is why Fehling et al. refer to them."^^xsd:string .


:StatefulComponent-to-ServerSessionState
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:StatefulComponent ;
    pp:hasTarget eaa:ServerSessionState ;
    pp:hasDescription "Server Session State stores the state of the corresponding component. The component becomes a stateful component."^^xsd:string .


:StatelessComponent-to-ClientSessionState
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:StatelessComponent ;
    pp:hasTarget eaa:ClientSessionState ;
    pp:hasDescription "Fowler's Session State Patterns explain how the state can be swapped out to external memory. The Client Session State Pattern stores the state on the client side. The state is sent with each request so that the components do not store it themselves. Changes to the state must be sent back with the request."^^xsd:string .


:StatelessComponent-to-DatabaseSessionState
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:StatelessComponent ;
    pp:hasTarget eaa:DatabaseSessionState ;
    pp:hasDescription "The state of a session is stored in a database with Database Session State. The component that needs the state can load it from the database and edit it. The state is then updated. The component itself does not have the status and is therefore stateless. However, a client must send a session ID or similar with a request, with which the component can request the corresponding status from the database."^^xsd:string .


:DataAccessComponent-to-TableDataGateway
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget eaa:TableDataGateway ;
    pp:hasDescription "Fehling et al. refer here to the patterns of Fowler. These include various data access patterns that can contribute to the implementation of the Data Access Component. These include, for example, the Table Data Gateway Pattern. This allows you to operate on a database table using provided methods instead of executing SQL commands directly."^^xsd:string .


:RestrictedDataAccessComponent-to-RemoteFacade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:RestrictedDataAccessComponent ;
    pp:hasTarget eaa:RemoteFacade ;
    pp:hasDescription "Fehling et al. go further into the remote facade of the EAA patterns. They note that the use of the Remote Facade can improve the efficiency of data retrieval. A Remote Facade bundles fine-grained objects to minimize calls. This pattern is generally suitable for the transmission of data within the network and not specifically for restricted data access components, so this is not deepened further."^^xsd:string .


:RestrictedDataAccessComponent-to-TableDataGateway
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:RestrictedDataAccessComponent ;
    pp:hasTarget eaa:TableDataGateway ;
    pp:hasDescription "The Table Data Gateway methods can restrict data according to rules before it is returned, so that clients do not have access to all data. This filtering then takes place within the component."^^xsd:string .


:DataAccessComponent-to-IdentityMap
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget eaa:IdentityMap ;
    pp:hasDescription "The Data Access Component of the Cloud Computing Patterns provides an interface for accessing the data. This interface can be either generic or customized to meet specific requirements. In the latter case, objects can be created from the database data within the Data Access Component, which are then sent to the clients. The administration of these objects can then take place in an identity map. With a generic interface, the clients themselves must take care of creating suitable objects. In the course of this, clients can keep an identity map for themselves in order to manage the objects."^^xsd:string .


:DataAccessComponent-to-ImplicitLock
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget eaa:ImplicitLock ;
    pp:hasDescription "In a cloud environment, a data access component, the cloud computing pattern, controls access to databases. Individual components communicate via it instead of operating directly on the databases. It thus offers a central interface. Implicit Lock is therefore used in the Data Access Component. Instead of explicitly setting the locks and releasing them again, the Data Access Component regulates this implicitly. From the perspective of the components, this happens automatically. Within the Data Access Component, various locking mechanisms such as Optimistic Offline Lock, Pessimistic Offline Lock or Coarse-Grained Lock can be used in the background."^^xsd:string .


:DataAccessComponent-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "The Data Access Component isolates complexity and provides unified access to data. To enable uniform access, the Data Access Component must be able to cope with different interfaces. One component that bridges the incompatibility of interfaces is an adapter. The adapter pattern of the GoF implements the interface that a client expects and executes the functions of the target component in the background. In this case, the client is any component that accesses the Data Access Component. The data access component acts as an adapter and the target component is the underlying datastore on which the data is stored."^^xsd:string .


:DataAccessComponent-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "Same concepts as in Data Access Component."^^xsd:string .


:ApplicationComponentProxy-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ApplicationComponentProxy ;
    pp:hasTarget gof:Proxy ;
    pp:hasDescription "The similarity to the Proxy Pattern and the Facade Pattern of the GoF is explained by Fehling et al. at this point. Instead of interacting directly with a component, a proxy is used which provides the same interface as the desired component. A facade simplifies interfaces by bundling the individual components under a single interface. This reduces dependency on multiple components, as communication now takes place via the facade. In the context of a facade, an Application Component Proxy can therefore be the interface for several underlying components. The proxy pattern can also be found in Buschmann et al. Patterns. However, this is the same pattern that has already been described by the GoF."^^xsd:string .


:ApplicationComponentProxy-to-Facade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ApplicationComponentProxy ;
    pp:hasTarget gof:Facade ;
    pp:hasDescription "The similarity to the Proxy Pattern and the Facade Pattern of the GoF is explained by Fehling et al. at this point. Instead of interacting directly with a component, a proxy is used which provides the same interface as the desired component. A facade simplifies interfaces by bundling the individual components under a single interface. This reduces dependency on multiple components, as communication now takes place via the facade. In the context of a facade, an Application Component Proxy can therefore be the interface for several underlying components. The proxy pattern can also be found in Buschmann et al. Patterns. However, this is the same pattern that has already been described by the GoF."^^xsd:string .


:ProviderAdapter-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ProviderAdapter ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "A provider adapter is an abstraction layer of the system and provides interfaces. Fehling et al. refer to concepts of the Adapter and Facade Pattern of the GoF. The Proxy Pattern by Buschmann et al. also describes concepts that can be applied here."^^xsd:string .


:ProviderAdapter-to-Facade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ProviderAdapter ;
    pp:hasTarget gof:Facade ;
    pp:hasDescription "A provider adapter is an abstraction layer of the system and provides interfaces. Fehling et al. refer to concepts of the Adapter and Facade Pattern of the GoF. The Proxy Pattern by Buschmann et al. also describes concepts that can be applied here."^^xsd:string .


:DeviceGateway-to-Watchdog
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource iot:DeviceGateway ;
    pp:hasTarget ccp:Watchdog ;
    pp:hasDescription "The Device Gateway can detect and replace defective devices that are connected to it. From this fact we have a relation to the watchdog pattern of Fehling et al., according to Reinfurt et al."^^xsd:string .


:LooseCoupling-to-Broker
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:LooseCoupling ;
    pp:hasTarget posa:Broker ;
    pp:hasDescription "Fehling et al. refer to the broker pattern of Buschmann et al. In a distributed system, the Broker Pattern takes care of the communication of individual components. Components can log on or off via the broker at runtime. If components need services from other components, they can access these functions via the broker."^^xsd:string .


:DistributedApplication-to-PipesandFilters
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DistributedApplication ;
    pp:hasTarget posa:PipesandFilters ;
    pp:hasDescription "The Pipes and Filters pattern is also found in the Pattern-Oriented Software Architecture Pattern. It is important to note that this variation does not refer to messaging. The data exchange takes place e.g. via files and not via concrete messages as in the EIP version. Furthermore, there are no router components that could influence the processing path. This means that the processing of the data always follows the same path and is independent of the concrete data."^^xsd:string .


:DistributedApplication-to-Layers
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DistributedApplication ;
    pp:hasTarget posa:Layers ;
    pp:hasDescription "The division of an application into layers is part of the layer pattern by Buschmann et al. Components that have similar tasks are grouped in a layer. The layers are sorted according to their functionalities. High-level functions can be found in the top layer and low-level functions in the bottom layer. For example, UI counts as a high-level, while low-level functions include the data. A layer can only communicate with its upper and lower layers in order to keep the dependencies between the layers as low as possible."^^xsd:string .


:DataAccessComponent-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget posa:Proxy ;
    pp:hasDescription "The Proxy Pattern from Buschmann et al. defines that clients communicate via a deputy instead of working directly on the component. Reasons for this are, for example, that changes to the components should have no influence on the clients. Furthermore for security reasons: A client should not be able to work directly on the component in order to prevent possible attacks on the system. Both reasons can also be found in the Data Access Component, which is why Fehling et al. refer to the Proxy Pattern."^^xsd:string .


:DataAccessComponent-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget posa:Proxy ;
    pp:hasDescription "Same concepts as in Data Access Component."^^xsd:string .


:Resequencer-to-IdentityField
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:Resequencer ;
    pp:hasTarget eaa:IdentityField ;
    pp:hasDescription "A provider adapter is an abstraction layer of the system and provides interfaces. Fehling et al. refer to concepts of the Adapter and Facade Pattern of the GoF. The Proxy Pattern by Buschmann et al. also describes concepts that can be applied here. Links can be found in the Identity Field of the Patterns of Enterprise Application Architecture. This is used as the sequence number for each message."^^xsd:string .


:MessagingGateway-to-Gateway
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingGateway ;
    pp:hasTarget eaa:Gateway ;
    pp:hasDescription "Hohpe and Woolf mention that Messaging Gateway is a variant of Folwer et al.'s Gateway Pattern. Essentially, a gateway comprises one or more components and regulates access to them. Instead of accessing the components directly, this is now done via the gateway."^^xsd:string .


:MessagingGateway-to-ServiceStub
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingGateway ;
    pp:hasTarget eaa:ServiceStub ;
    pp:hasDescription "Hohpe and Woolf refer to the Service Stub Pattern by Folwer et al. which enables testing. The Messaging Gateway provides an interface to the outside world so that components can make enquiries. In the background we have two implementations of this interface: the real component and a dummy or mock. If we want to test our system, we switch to the mock implementation and can test it accordingly."^^xsd:string .


:MessagingMapper-to-Mapper
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingMapper ;
    pp:hasTarget eaa:Mapper ;
    pp:hasDescription "The Messaging Mapper is based on the Mapper Pattern by Fowler et al., which is why Hohpe and Woolf refer to it. A mapper generally ensures that two components can communicate with each other even though their objects are incompatible. The components remain independent of each other and are not aware of the mapper."^^xsd:string .


:MessagingMapper-to-DataMapper
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingMapper ;
    pp:hasTarget eaa:DataMapper ;
    pp:hasDescription "The mapping between object and message has similarities to object-relational mapping. For the latter, there are several patterns by Fowler et al. that deal with this problem. These include for example the Data Mapper Pattern."^^xsd:string .


:MessagingMapper-to-DataTransferObject
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingMapper ;
    pp:hasTarget eaa:DataTransferObject ;
    pp:hasDescription "As described above, one-to-one mapping of message and domain object is not always the best solution. In some scenarios, it is recommended, for example, to bundle several smaller objects in one message. The messaging mapper ensures that the data is placed in the corresponding objects or that the correct objects are packed into a message. This procedure can be found in the Data Transfer Object from the patterns by Fowler et al. Because of this similarity, Hohpe and Woolf refer to this pattern."^^xsd:string .


:ServiceActivator-to-ServiceLayer
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:ServiceActivator ;
    pp:hasTarget eaa:ServiceLayer ;
    pp:hasDescription "Hohpe and Woolf refer to the Service Layer Pattern by Fowler et al. A service layer is an abstraction layer of an application and provides a clear API. A service provided by an application corresponds to an operation in a service layer. The Service Activator ensures that the operations can be called via messages."^^xsd:string .


:ClaimCheck-to-IdentityField
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:ClaimCheck ;
    pp:hasTarget eaa:IdentityField ;
    pp:hasDescription "In the Enterprise Integration Patterns claim check pattern, data is swapped out to reduce the message size. An identifier in the form of the claim check is stored in the message so that the data can be removed again later. An identity field could be used as an identifier. Transferred data is entered into the database, the primary key is stored in the Identity Field and added to the message."^^xsd:string .


:MessagingMapper-to-MetadataMapping
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingMapper ;
    pp:hasTarget eaa:MetadataMapping ;
    pp:hasDescription "Metadata mapping can be used to generate messages in the context of messaging. The actual use of this pattern is in databases, but the associated mechanics can also be used for messaging. A Messaging Mapper of the Enterprise Integration Patterns generates a message from an object based on the metadata and vice versa. For example, if XML is selected as the message type, the table and column names are XML tags or attributes. Object fields are mapped with these tags and attributes."^^xsd:string .


:TransformView-to-MessageTranslator
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:TransformView ;
    pp:hasTarget eip:MessageTranslator ;
    pp:hasDescription "With this pattern we have similarities to the Message Translator pattern of Hohpe and Woolf. We have two systems in this construction. On the one hand we have the website, which expects the data in HTML format. On the other side is the model. The Transform View serves as a translator and converts the model data into HTML format. The big difference is that we are not in the context of messaging. It is only about the conversion into a target format. It can be transferred to messaging if the two systems are remote systems and communication is via messaging."^^xsd:string .


:TransactionScript-to-Command
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:TransactionScript ;
    pp:hasTarget gof:Command ;
    pp:hasDescription "This pattern is about sending objects over the network. In the Enterprise Integration Patterns in the context of messaging, objects are sent in the form of a document message. The payload of this message corresponds to the object. To reduce the number of messages, you can use the Data Transfer Object Pattern by storing all required data in the document message. Multiple Transaction Scripts can either all be found in one class or we have one class per procedure. The second variant is an implementation of the command pattern of the GoF, which is why Fowler refers to it. We create a superclass that provides a method for implementing the functionality of the transaction script. Subclasses implement their concrete functions into this method."^^xsd:string .


:LazyLoad-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:LazyLoad ;
    pp:hasTarget gof:Proxy ;
    pp:hasDescription "With Lazy Load via Lazy Initialization, the object fields are checked for zero before use. If a field is null, it is now loaded and returned so that it can be used. This procedure corresponds to the Virtual Proxy Pattern of the GoF, which is why Fowler refers to it. The Virtual Proxy is a variant of the Proxy Pattern. This only generates the objects behind the proxy when the methods are called. However, the proxy itself has the same interface as the objects."^^xsd:string .


:SerializedLOB-to-Memento
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:SerializedLOB ;
    pp:hasTarget gof:Memento ;
    pp:hasDescription "Fowler refers to the memento pattern of the GoF. Memento takes a snapshot of an object. The snapshot contains the complete inner state of an object. This includes the values of the individual fields. The memento can be saved serialized and thus becomes a Serialized LOB."^^xsd:string .


:RemoteFacade-to-Facade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:RemoteFacade ;
    pp:hasTarget gof:Facade ;
    pp:hasDescription "Fowler points out that this pattern is a variation of the Facade pattern of the GoF. The Facade Pattern bundles interfaces of several components. This means that there is one interface, the Facade, which allows central access to these components. The Remote Facade has the same function, but it is specially designed for remote components, i.e. remote components that are addressed via the network."^^xsd:string .


:Gateway-to-Facade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:Gateway ;
    pp:hasTarget gof:Facade ;
    pp:hasDescription "Links can be found in the Gang of Four Pattern Facade and Adapter. Fowler distinguishes its Gateway Pattern from the above as follows: A Facade simplifies an API, Gateway however adapts the API to its own needs. An adapter, on the other hand, adapts two different interfaces so that they can work together, while Gateway can use adapters as part of its implementation."^^xsd:string .


:Gateway-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:Gateway ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "Links can be found in the Gang of Four Pattern Facade and Adapter. Fowler distinguishes its Gateway Pattern from the above as follows: A Facade simplifies an API, Gateway however adapts the API to its own needs. An adapter, on the other hand, adapts two different interfaces so that they can work together, while Gateway can use adapters as part of its implementation."^^xsd:string .


:Mapper-to-Observer
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:Mapper ;
    pp:hasTarget gof:Observer ;
    pp:hasDescription "The challenge of these patterns is to call the mapper, because the subsystems should not know it. One possibility is the Observer pattern of the GoF, which is why Fowler refers to it. The mapper acts as observer for one of the systems and is triggered at events, i.e. called without this system explicitly knowing the mapper. From its point of view, it is merely a listener in its list."^^xsd:string .


:Mapper-to-Mediator
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:Mapper ;
    pp:hasTarget gof:Mediator ;
    pp:hasDescription "Fowler references the similarity to the Mediator Pattern of the GoF, which also decouples systems. The big difference, however, is that the systems know the mediator, which is not the case with the mapper. Systems can therefore explicitly call the mediator."^^xsd:string .


:DeviceShadow-to-OptimisticOfflineLock
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource iot:DeviceShadow ;
    pp:hasTarget eaa:OptimisticOfflineLock ;
    pp:hasDescription "Due to possible synchronization problems that may occur when synchronizing the state, Reinfurt et al. refer to Fowler's Optimistic Offline Lock Pattern."^^xsd:string .


:MessageTranslator-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessageTranslator ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "Hohpe and Woolf refer here to the adapter pattern of the Gang of Four. This also ensures that two different interfaces are compatible with each other."^^xsd:string .


:Publish-SubscribeChannel-to-Observer
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:Publish-SubscribeChannel ;
    pp:hasTarget gof:Observer ;
    pp:hasDescription "Publish Subscribe Channels extend the Observer Pattern of the Gang of Four. In the Observer Pattern we have subjects who announce changes to their state and Observers who are interested in these changes. The number of Observers does not matter, i.e. no Observer can be aware of changes in the state of a subject. In the Observer pattern, subject and observer are in the same application, which is why the information about local method calls is implemented. For distributed applications in the context of messaging we can use Publish-Subscribe Channel. Subjects get a message gateway that propagates changes of the subject from Notify() to the channel. Observers also get message gateways that read the propagated changes via the channel and forward them to the underlying observers. Observers register by subscribing to the Publish Subscribe Channel."^^xsd:string .


:CommandMessage-to-Command
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:CommandMessage ;
    pp:hasTarget gof:Command ;
    pp:hasDescription "This pattern is a message variant of the command pattern of the Gang of Four, so Hohpe and Woolf. A command or request is stored in an object and can therefore be passed on. It contains all the information necessary to execute the command."^^xsd:string .


:RoutingSlip-to-ChainofResponsibility
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:RoutingSlip ;
    pp:hasTarget gof:ChainofResponsibility ;
    pp:hasDescription "Routing slip is a modification of the Chain of Responsibility of the Gang of Four, according to Hohpe and Woolf. We define a static chain of responsibility that includes objects or components that can handle a request. A request passes through this chain until it is processed by an object. Each component decides according to the list one after the other whether it wants to handle the request or pass it on."^^xsd:string .


:MessagingMapper-to-Mediator
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingMapper ;
    pp:hasTarget gof:Mediator ;
    pp:hasDescription "The intention of the Messaging Mapper can also be found in the Mediator Pattern of the GoF. A lot of components communicate with each other through a mediator, the Mediator, which coordinates their interactions. In the mediator, the objects involved have a reference to the mediator instead of references to the corresponding components. The big difference to the Messaging Mapper, however, is that the components involved do not know the Mapper or take no notice of it."^^xsd:string .


