# Definition of prefixes
@prefix : <https://purl.org/patternpedia/patternviews/https://purl.org/patternpedia/patternviews/enterpriseapplicationarchitecturepatterns-enterpriseintegrationpatterns-view#> .
@prefix pp: <https://purl.org/patternpedia#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix eaa: <https://purl.org/patternpedia/patternlanguages/enterpriseapplicationarchitecturepatterns#> .
@prefix eip: <https://purl.org/patternpedia/patternlanguages/enterpriseintegrationpatterns#> .


:Key-ValueStorage-to-DomainModel
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:Key-ValueStorage ;
    pp:hasTarget eaa:DomainModel ;
    pp:hasDescription "The domain model, consisting of data and the functionality to access it, decides whether key-value storage is the right choice. Patterns for domain models can be found in the Patterns of Enterprise Application Architecture by Fowler et al., which is why Fehling et al. refer to them."^^xsd:string .


:StatefulComponent-to-ServerSessionState
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:StatefulComponent ;
    pp:hasTarget eaa:ServerSessionState ;
    pp:hasDescription "Server Session State stores the state of the corresponding component. The component becomes a stateful component."^^xsd:string .


:StatelessComponent-to-ClientSessionState
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:StatelessComponent ;
    pp:hasTarget eaa:ClientSessionState ;
    pp:hasDescription "Fowler's Session State Patterns explain how the state can be swapped out to external memory. The Client Session State Pattern stores the state on the client side. The state is sent with each request so that the components do not store it themselves. Changes to the state must be sent back with the request."^^xsd:string .


:StatelessComponent-to-DatabaseSessionState
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:StatelessComponent ;
    pp:hasTarget eaa:DatabaseSessionState ;
    pp:hasDescription "The state of a session is stored in a database with Database Session State. The component that needs the state can load it from the database and edit it. The state is then updated. The component itself does not have the status and is therefore stateless. However, a client must send a session ID or similar with a request, with which the component can request the corresponding status from the database."^^xsd:string .


:DataAccessComponent-to-TableDataGateway
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget eaa:TableDataGateway ;
    pp:hasDescription "Fehling et al. refer here to the patterns of Fowler. These include various data access patterns that can contribute to the implementation of the Data Access Component. These include, for example, the Table Data Gateway Pattern. This allows you to operate on a database table using provided methods instead of executing SQL commands directly."^^xsd:string .


:RestrictedDataAccessComponent-to-RemoteFacade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:RestrictedDataAccessComponent ;
    pp:hasTarget eaa:RemoteFacade ;
    pp:hasDescription "Fehling et al. go further into the remote facade of the EAA patterns. They note that the use of the Remote Facade can improve the efficiency of data retrieval. A Remote Facade bundles fine-grained objects to minimize calls. This pattern is generally suitable for the transmission of data within the network and not specifically for restricted data access components, so this is not deepened further."^^xsd:string .


:RestrictedDataAccessComponent-to-TableDataGateway
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:RestrictedDataAccessComponent ;
    pp:hasTarget eaa:TableDataGateway ;
    pp:hasDescription "The Table Data Gateway methods can restrict data according to rules before it is returned, so that clients do not have access to all data. This filtering then takes place within the component."^^xsd:string .


:DataAccessComponent-to-IdentityMap
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget eaa:IdentityMap ;
    pp:hasDescription "The Data Access Component of the Cloud Computing Patterns provides an interface for accessing the data. This interface can be either generic or customized to meet specific requirements. In the latter case, objects can be created from the database data within the Data Access Component, which are then sent to the clients. The administration of these objects can then take place in an identity map. With a generic interface, the clients themselves must take care of creating suitable objects. In the course of this, clients can keep an identity map for themselves in order to manage the objects."^^xsd:string .


:DataAccessComponent-to-ImplicitLock
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget eaa:ImplicitLock ;
    pp:hasDescription "In a cloud environment, a data access component, the cloud computing pattern, controls access to databases. Individual components communicate via it instead of operating directly on the databases. It thus offers a central interface. Implicit Lock is therefore used in the Data Access Component. Instead of explicitly setting the locks and releasing them again, the Data Access Component regulates this implicitly. From the perspective of the components, this happens automatically. Within the Data Access Component, various locking mechanisms such as Optimistic Offline Lock, Pessimistic Offline Lock or Coarse-Grained Lock can be used in the background."^^xsd:string .


:DataAccessComponent-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "The Data Access Component isolates complexity and provides unified access to data. To enable uniform access, the Data Access Component must be able to cope with different interfaces. One component that bridges the incompatibility of interfaces is an adapter. The adapter pattern of the GoF implements the interface that a client expects and executes the functions of the target component in the background. In this case, the client is any component that accesses the Data Access Component. The data access component acts as an adapter and the target component is the underlying datastore on which the data is stored."^^xsd:string .


:DataAccessComponent-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "Same concepts as in Data Access Component."^^xsd:string .


:ApplicationComponentProxy-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ApplicationComponentProxy ;
    pp:hasTarget gof:Proxy ;
    pp:hasDescription "The similarity to the Proxy Pattern and the Facade Pattern of the GoF is explained by Fehling et al. at this point. Instead of interacting directly with a component, a proxy is used which provides the same interface as the desired component. A facade simplifies interfaces by bundling the individual components under a single interface. This reduces dependency on multiple components, as communication now takes place via the facade. In the context of a facade, an Application Component Proxy can therefore be the interface for several underlying components. The proxy pattern can also be found in Buschmann et al. Patterns. However, this is the same pattern that has already been described by the GoF."^^xsd:string .


:ApplicationComponentProxy-to-Facade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ApplicationComponentProxy ;
    pp:hasTarget gof:Facade ;
    pp:hasDescription "The similarity to the Proxy Pattern and the Facade Pattern of the GoF is explained by Fehling et al. at this point. Instead of interacting directly with a component, a proxy is used which provides the same interface as the desired component. A facade simplifies interfaces by bundling the individual components under a single interface. This reduces dependency on multiple components, as communication now takes place via the facade. In the context of a facade, an Application Component Proxy can therefore be the interface for several underlying components. The proxy pattern can also be found in Buschmann et al. Patterns. However, this is the same pattern that has already been described by the GoF."^^xsd:string .


:ProviderAdapter-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ProviderAdapter ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "A provider adapter is an abstraction layer of the system and provides interfaces. Fehling et al. refer to concepts of the Adapter and Facade Pattern of the GoF. The Proxy Pattern by Buschmann et al. also describes concepts that can be applied here."^^xsd:string .


:ProviderAdapter-to-Facade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ProviderAdapter ;
    pp:hasTarget gof:Facade ;
    pp:hasDescription "A provider adapter is an abstraction layer of the system and provides interfaces. Fehling et al. refer to concepts of the Adapter and Facade Pattern of the GoF. The Proxy Pattern by Buschmann et al. also describes concepts that can be applied here."^^xsd:string .


:DeviceGateway-to-Watchdog
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource iot:DeviceGateway ;
    pp:hasTarget ccp:Watchdog ;
    pp:hasDescription "The Device Gateway can detect and replace defective devices that are connected to it. From this fact we have a relation to the watchdog pattern of Fehling et al., according to Reinfurt et al."^^xsd:string .


:LooseCoupling-to-Broker
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:LooseCoupling ;
    pp:hasTarget posa:Broker ;
    pp:hasDescription "Fehling et al. refer to the broker pattern of Buschmann et al. In a distributed system, the Broker Pattern takes care of the communication of individual components. Components can log on or off via the broker at runtime. If components need services from other components, they can access these functions via the broker."^^xsd:string .


:DistributedApplication-to-PipesandFilters
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DistributedApplication ;
    pp:hasTarget posa:PipesandFilters ;
    pp:hasDescription "The Pipes and Filters pattern is also found in the Pattern-Oriented Software Architecture Pattern. It is important to note that this variation does not refer to messaging. The data exchange takes place e.g. via files and not via concrete messages as in the EIP version. Furthermore, there are no router components that could influence the processing path. This means that the processing of the data always follows the same path and is independent of the concrete data."^^xsd:string .


:DistributedApplication-to-Layers
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DistributedApplication ;
    pp:hasTarget posa:Layers ;
    pp:hasDescription "The division of an application into layers is part of the layer pattern by Buschmann et al. Components that have similar tasks are grouped in a layer. The layers are sorted according to their functionalities. High-level functions can be found in the top layer and low-level functions in the bottom layer. For example, UI counts as a high-level, while low-level functions include the data. A layer can only communicate with its upper and lower layers in order to keep the dependencies between the layers as low as possible."^^xsd:string .


:DataAccessComponent-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget posa:Proxy ;
    pp:hasDescription "The Proxy Pattern from Buschmann et al. defines that clients communicate via a deputy instead of working directly on the component. Reasons for this are, for example, that changes to the components should have no influence on the clients. Furthermore for security reasons: A client should not be able to work directly on the component in order to prevent possible attacks on the system. Both reasons can also be found in the Data Access Component, which is why Fehling et al. refer to the Proxy Pattern."^^xsd:string .


:DataAccessComponent-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget posa:Proxy ;
    pp:hasDescription "Same concepts as in Data Access Component."^^xsd:string .


:Resequencer-to-IdentityField
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:Resequencer ;
    pp:hasTarget eaa:IdentityField ;
    pp:hasDescription "A provider adapter is an abstraction layer of the system and provides interfaces. Fehling et al. refer to concepts of the Adapter and Facade Pattern of the GoF. The Proxy Pattern by Buschmann et al. also describes concepts that can be applied here. Links can be found in the Identity Field of the Patterns of Enterprise Application Architecture. This is used as the sequence number for each message."^^xsd:string .


:MessagingGateway-to-Gateway
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingGateway ;
    pp:hasTarget eaa:Gateway ;
    pp:hasDescription "Hohpe and Woolf mention that Messaging Gateway is a variant of Folwer et al.'s Gateway Pattern. Essentially, a gateway comprises one or more components and regulates access to them. Instead of accessing the components directly, this is now done via the gateway."^^xsd:string .


:MessagingGateway-to-ServiceStub
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingGateway ;
    pp:hasTarget eaa:ServiceStub ;
    pp:hasDescription "Hohpe and Woolf refer to the Service Stub Pattern by Folwer et al. which enables testing. The Messaging Gateway provides an interface to the outside world so that components can make enquiries. In the background we have two implementations of this interface: the real component and a dummy or mock. If we want to test our system, we switch to the mock implementation and can test it accordingly."^^xsd:string .


:MessagingMapper-to-Mapper
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingMapper ;
    pp:hasTarget eaa:Mapper ;
    pp:hasDescription "The Messaging Mapper is based on the Mapper Pattern by Fowler et al., which is why Hohpe and Woolf refer to it. A mapper generally ensures that two components can communicate with each other even though their objects are incompatible. The components remain independent of each other and are not aware of the mapper."^^xsd:string .


:MessagingMapper-to-DataMapper
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingMapper ;
    pp:hasTarget eaa:DataMapper ;
    pp:hasDescription "The mapping between object and message has similarities to object-relational mapping. For the latter, there are several patterns by Fowler et al. that deal with this problem. These include for example the Data Mapper Pattern."^^xsd:string .


:MessagingMapper-to-DataTransferObject
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingMapper ;
    pp:hasTarget eaa:DataTransferObject ;
    pp:hasDescription "As described above, one-to-one mapping of message and domain object is not always the best solution. In some scenarios, it is recommended, for example, to bundle several smaller objects in one message. The messaging mapper ensures that the data is placed in the corresponding objects or that the correct objects are packed into a message. This procedure can be found in the Data Transfer Object from the patterns by Fowler et al. Because of this similarity, Hohpe and Woolf refer to this pattern."^^xsd:string .


:ServiceActivator-to-ServiceLayer
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:ServiceActivator ;
    pp:hasTarget eaa:ServiceLayer ;
    pp:hasDescription "Hohpe and Woolf refer to the Service Layer Pattern by Fowler et al. A service layer is an abstraction layer of an application and provides a clear API. A service provided by an application corresponds to an operation in a service layer. The Service Activator ensures that the operations can be called via messages."^^xsd:string .


:ClaimCheck-to-IdentityField
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:ClaimCheck ;
    pp:hasTarget eaa:IdentityField ;
    pp:hasDescription "In the Enterprise Integration Patterns claim check pattern, data is swapped out to reduce the message size. An identifier in the form of the claim check is stored in the message so that the data can be removed again later. An identity field could be used as an identifier. Transferred data is entered into the database, the primary key is stored in the Identity Field and added to the message."^^xsd:string .


:MessagingMapper-to-MetadataMapping
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eip:MessagingMapper ;
    pp:hasTarget eaa:MetadataMapping ;
    pp:hasDescription "Metadata mapping can be used to generate messages in the context of messaging. The actual use of this pattern is in databases, but the associated mechanics can also be used for messaging. A Messaging Mapper of the Enterprise Integration Patterns generates a message from an object based on the metadata and vice versa. For example, if XML is selected as the message type, the table and column names are XML tags or attributes. Object fields are mapped with these tags and attributes."^^xsd:string .


:TransformView-to-MessageTranslator
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource eaa:TransformView ;
    pp:hasTarget eip:MessageTranslator ;
    pp:hasDescription "With this pattern we have similarities to the Message Translator pattern of Hohpe and Woolf. We have two systems in this construction. On the one hand we have the website, which expects the data in HTML format. On the other side is the model. The Transform View serves as a translator and converts the model data into HTML format. The big difference is that we are not in the context of messaging. It is only about the conversion into a target format. It can be transferred to messaging if the two systems are remote systems and communication is via messaging."^^xsd:string .


