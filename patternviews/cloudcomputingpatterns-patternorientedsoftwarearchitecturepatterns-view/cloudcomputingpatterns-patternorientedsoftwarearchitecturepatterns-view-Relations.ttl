# Definition of prefixes
@prefix : <https://purl.org/patternpedia/patternviews/https://purl.org/patternpedia/patternviews/cloudcomputingpatterns-patternorientedsoftwarearchitecturepatterns-view#> .
@prefix pp: <https://purl.org/patternpedia#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix ccp: <https://purl.org/patternpedia/patternlanguages/cloudcomputingpatterns#> .
@prefix posa: <https://purl.org/patternpedia/patternlanguages/patternorientedsoftwarearchitecturepatterns#> .


:Key-ValueStorage-to-DomainModel
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:Key-ValueStorage ;
    pp:hasTarget eaa:DomainModel ;
    pp:hasDescription "The domain model, consisting of data and the functionality to access it, decides whether key-value storage is the right choice. Patterns for domain models can be found in the Patterns of Enterprise Application Architecture by Fowler et al., which is why Fehling et al. refer to them."^^xsd:string .


:StatefulComponent-to-ServerSessionState
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:StatefulComponent ;
    pp:hasTarget eaa:ServerSessionState ;
    pp:hasDescription "Server Session State stores the state of the corresponding component. The component becomes a stateful component."^^xsd:string .


:StatelessComponent-to-ClientSessionState
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:StatelessComponent ;
    pp:hasTarget eaa:ClientSessionState ;
    pp:hasDescription "Fowler's Session State Patterns explain how the state can be swapped out to external memory. The Client Session State Pattern stores the state on the client side. The state is sent with each request so that the components do not store it themselves. Changes to the state must be sent back with the request."^^xsd:string .


:StatelessComponent-to-DatabaseSessionState
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:StatelessComponent ;
    pp:hasTarget eaa:DatabaseSessionState ;
    pp:hasDescription "The state of a session is stored in a database with Database Session State. The component that needs the state can load it from the database and edit it. The state is then updated. The component itself does not have the status and is therefore stateless. However, a client must send a session ID or similar with a request, with which the component can request the corresponding status from the database."^^xsd:string .


:DataAccessComponent-to-TableDataGateway
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget eaa:TableDataGateway ;
    pp:hasDescription "Fehling et al. refer here to the patterns of Fowler. These include various data access patterns that can contribute to the implementation of the Data Access Component. These include, for example, the Table Data Gateway Pattern. This allows you to operate on a database table using provided methods instead of executing SQL commands directly."^^xsd:string .


:RestrictedDataAccessComponent-to-RemoteFacade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:RestrictedDataAccessComponent ;
    pp:hasTarget eaa:RemoteFacade ;
    pp:hasDescription "Fehling et al. go further into the remote facade of the EAA patterns. They note that the use of the Remote Facade can improve the efficiency of data retrieval. A Remote Facade bundles fine-grained objects to minimize calls. This pattern is generally suitable for the transmission of data within the network and not specifically for restricted data access components, so this is not deepened further."^^xsd:string .


:RestrictedDataAccessComponent-to-TableDataGateway
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:RestrictedDataAccessComponent ;
    pp:hasTarget eaa:TableDataGateway ;
    pp:hasDescription "The Table Data Gateway methods can restrict data according to rules before it is returned, so that clients do not have access to all data. This filtering then takes place within the component."^^xsd:string .


:DataAccessComponent-to-IdentityMap
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget eaa:IdentityMap ;
    pp:hasDescription "The Data Access Component of the Cloud Computing Patterns provides an interface for accessing the data. This interface can be either generic or customized to meet specific requirements. In the latter case, objects can be created from the database data within the Data Access Component, which are then sent to the clients. The administration of these objects can then take place in an identity map. With a generic interface, the clients themselves must take care of creating suitable objects. In the course of this, clients can keep an identity map for themselves in order to manage the objects."^^xsd:string .


:DataAccessComponent-to-ImplicitLock
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget eaa:ImplicitLock ;
    pp:hasDescription "In a cloud environment, a data access component, the cloud computing pattern, controls access to databases. Individual components communicate via it instead of operating directly on the databases. It thus offers a central interface. Implicit Lock is therefore used in the Data Access Component. Instead of explicitly setting the locks and releasing them again, the Data Access Component regulates this implicitly. From the perspective of the components, this happens automatically. Within the Data Access Component, various locking mechanisms such as Optimistic Offline Lock, Pessimistic Offline Lock or Coarse-Grained Lock can be used in the background."^^xsd:string .


:DataAccessComponent-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "The Data Access Component isolates complexity and provides unified access to data. To enable uniform access, the Data Access Component must be able to cope with different interfaces. One component that bridges the incompatibility of interfaces is an adapter. The adapter pattern of the GoF implements the interface that a client expects and executes the functions of the target component in the background. In this case, the client is any component that accesses the Data Access Component. The data access component acts as an adapter and the target component is the underlying datastore on which the data is stored."^^xsd:string .


:DataAccessComponent-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "Same concepts as in Data Access Component."^^xsd:string .


:ApplicationComponentProxy-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ApplicationComponentProxy ;
    pp:hasTarget gof:Proxy ;
    pp:hasDescription "The similarity to the Proxy Pattern and the Facade Pattern of the GoF is explained by Fehling et al. at this point. Instead of interacting directly with a component, a proxy is used which provides the same interface as the desired component. A facade simplifies interfaces by bundling the individual components under a single interface. This reduces dependency on multiple components, as communication now takes place via the facade. In the context of a facade, an Application Component Proxy can therefore be the interface for several underlying components. The proxy pattern can also be found in Buschmann et al. Patterns. However, this is the same pattern that has already been described by the GoF."^^xsd:string .


:ApplicationComponentProxy-to-Facade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ApplicationComponentProxy ;
    pp:hasTarget gof:Facade ;
    pp:hasDescription "The similarity to the Proxy Pattern and the Facade Pattern of the GoF is explained by Fehling et al. at this point. Instead of interacting directly with a component, a proxy is used which provides the same interface as the desired component. A facade simplifies interfaces by bundling the individual components under a single interface. This reduces dependency on multiple components, as communication now takes place via the facade. In the context of a facade, an Application Component Proxy can therefore be the interface for several underlying components. The proxy pattern can also be found in Buschmann et al. Patterns. However, this is the same pattern that has already been described by the GoF."^^xsd:string .


:ProviderAdapter-to-Adapter
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ProviderAdapter ;
    pp:hasTarget gof:Adapter ;
    pp:hasDescription "A provider adapter is an abstraction layer of the system and provides interfaces. Fehling et al. refer to concepts of the Adapter and Facade Pattern of the GoF. The Proxy Pattern by Buschmann et al. also describes concepts that can be applied here."^^xsd:string .


:ProviderAdapter-to-Facade
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:ProviderAdapter ;
    pp:hasTarget gof:Facade ;
    pp:hasDescription "A provider adapter is an abstraction layer of the system and provides interfaces. Fehling et al. refer to concepts of the Adapter and Facade Pattern of the GoF. The Proxy Pattern by Buschmann et al. also describes concepts that can be applied here."^^xsd:string .


:DeviceGateway-to-Watchdog
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource iot:DeviceGateway ;
    pp:hasTarget ccp:Watchdog ;
    pp:hasDescription "The Device Gateway can detect and replace defective devices that are connected to it. From this fact we have a relation to the watchdog pattern of Fehling et al., according to Reinfurt et al."^^xsd:string .


:LooseCoupling-to-Broker
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:LooseCoupling ;
    pp:hasTarget posa:Broker ;
    pp:hasDescription "Fehling et al. refer to the broker pattern of Buschmann et al. In a distributed system, the Broker Pattern takes care of the communication of individual components. Components can log on or off via the broker at runtime. If components need services from other components, they can access these functions via the broker."^^xsd:string .


:DistributedApplication-to-PipesandFilters
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DistributedApplication ;
    pp:hasTarget posa:PipesandFilters ;
    pp:hasDescription "The Pipes and Filters pattern is also found in the Pattern-Oriented Software Architecture Pattern. It is important to note that this variation does not refer to messaging. The data exchange takes place e.g. via files and not via concrete messages as in the EIP version. Furthermore, there are no router components that could influence the processing path. This means that the processing of the data always follows the same path and is independent of the concrete data."^^xsd:string .


:DistributedApplication-to-Layers
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DistributedApplication ;
    pp:hasTarget posa:Layers ;
    pp:hasDescription "The division of an application into layers is part of the layer pattern by Buschmann et al. Components that have similar tasks are grouped in a layer. The layers are sorted according to their functionalities. High-level functions can be found in the top layer and low-level functions in the bottom layer. For example, UI counts as a high-level, while low-level functions include the data. A layer can only communicate with its upper and lower layers in order to keep the dependencies between the layers as low as possible."^^xsd:string .


:DataAccessComponent-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget posa:Proxy ;
    pp:hasDescription "The Proxy Pattern from Buschmann et al. defines that clients communicate via a deputy instead of working directly on the component. Reasons for this are, for example, that changes to the components should have no influence on the clients. Furthermore for security reasons: A client should not be able to work directly on the component in order to prevent possible attacks on the system. Both reasons can also be found in the Data Access Component, which is why Fehling et al. refer to the Proxy Pattern."^^xsd:string .


:DataAccessComponent-to-Proxy
    rdf:type owl:NamedIndividual, pp:DirectedPatternRelationDescriptor ;
    pp:hasSource ccp:DataAccessComponent ;
    pp:hasTarget posa:Proxy ;
    pp:hasDescription "Same concepts as in Data Access Component."^^xsd:string .


